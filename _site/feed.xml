<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2018-03-25T12:04:41+08:00</updated><id>http://localhost:4000/</id><title type="html">a Saleana</title><subtitle>a Saleana
</subtitle><author><name>Jia</name></author><entry><title type="html">A Note about Timer</title><link href="http://localhost:4000/2018/03/24/timer.html" rel="alternate" type="text/html" title="A Note about Timer" /><published>2018-03-24T00:00:00+08:00</published><updated>2018-03-24T00:00:00+08:00</updated><id>http://localhost:4000/2018/03/24/timer</id><content type="html" xml:base="http://localhost:4000/2018/03/24/timer.html">&lt;p&gt;Main components of a Timer class implemented in C++. I used to have a hard time thinking this through, so I guess I’d better keep a note of it.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Private variable needed
Unit32 startTicks = 0; // This is indeed the starting time
Unit32 pausedTicks = 0; // This is indeed the length of pasued time
bool started; // This is not illustrated in this example
bool pasued;

// Note: SDL_GetTicks() will return the current clock time; it is given by the SDL library (std library time.h also works)

// Three key functions shown below

Timer::pause() {
	if (!pasued) {
		paused = true;		
		// How long the timer has started;
		// When pause() is called, the timer screen freezes to display this time
		pausedTicks = SDL_GetTicks() - startTicks;
		// When pasue() is called, startTicks initializes
		startTicks = 0;
	}
}

Timer::unpause() {
	if (paused) {
		pasued = false;
		// Subtract the paused time, as if it never pauses
		startTicks = SDL_GetTicks() - pausedTicks;
		// Paused time for this round is no longer needed after we unpause the timer
		pausedTicks = 0;
	}
}

Unit32 Timer::getDisplayTime() {
	Unit32 time = 0;
	if( paused ) {
		// When pasued, display this fixed value
		time = pausedTicks;
	}
	else {
		// Normal case, simply subtracting starting time from current time
		time = SDL_GetTicks() - startTicks;
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hopefully this is a sufficiently clear explanation of how a timer works!&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Jia</name></author><category term="basics" /><summary type="html">Main components of a Timer class implemented in C++. I used to have a hard time thinking this through, so I guess I’d better keep a note of it. // Private variable needed Unit32 startTicks = 0; // This is indeed the starting time Unit32 pausedTicks = 0; // This is indeed the length of pasued time bool started; // This is not illustrated in this example bool pasued; // Note: SDL_GetTicks() will return the current clock time; it is given by the SDL library (std library time.h also works) // Three key functions shown below Timer::pause() { if (!pasued) { paused = true; // How long the timer has started; // When pause() is called, the timer screen freezes to display this time pausedTicks = SDL_GetTicks() - startTicks; // When pasue() is called, startTicks initializes startTicks = 0; } } Timer::unpause() { if (paused) { pasued = false; // Subtract the paused time, as if it never pauses startTicks = SDL_GetTicks() - pausedTicks; // Paused time for this round is no longer needed after we unpause the timer pausedTicks = 0; } } Unit32 Timer::getDisplayTime() { Unit32 time = 0; if( paused ) { // When pasued, display this fixed value time = pausedTicks; } else { // Normal case, simply subtracting starting time from current time time = SDL_GetTicks() - startTicks; } } Hopefully this is a sufficiently clear explanation of how a timer works!</summary></entry><entry><title type="html">Small “Dictionary” for Programmer</title><link href="http://localhost:4000/2018/03/24/cs-dictionary.html" rel="alternate" type="text/html" title="Small &quot;Dictionary&quot; for Programmer" /><published>2018-03-24T00:00:00+08:00</published><updated>2018-03-24T00:00:00+08:00</updated><id>http://localhost:4000/2018/03/24/cs-dictionary</id><content type="html" xml:base="http://localhost:4000/2018/03/24/cs-dictionary.html">&lt;p&gt;npm : Node Package Manager&lt;/p&gt;</content><author><name>Jia</name></author><category term="basics" /><summary type="html">npm : Node Package Manager</summary></entry><entry><title type="html">Programming Basics 编程的一些基本常识</title><link href="http://localhost:4000/2018/03/19/programming-basics.html" rel="alternate" type="text/html" title="Programming Basics 编程的一些基本常识" /><published>2018-03-19T00:00:00+08:00</published><updated>2018-03-19T00:00:00+08:00</updated><id>http://localhost:4000/2018/03/19/programming-basics</id><content type="html" xml:base="http://localhost:4000/2018/03/19/programming-basics.html">&lt;p&gt;每天学一点。先写中文的。&lt;/p&gt;

&lt;h4 id=&quot;ide-integrated-development-environment集成开发环境&quot;&gt;IDE: Integrated Development Environment 集成开发环境&lt;/h4&gt;

&lt;p&gt;IDE是应用程序。代码编辑器。可以有额外的编译功能、设计UI功能。&lt;/p&gt;

&lt;p&gt;如: Visual Studio, Android Studio, NetBeans(Oracle, Java), Eclipse, Xcode.&lt;/p&gt;

&lt;p&gt;Sorce code editor is a part of IDE.&lt;/p&gt;

&lt;p&gt;Example: Sublime text, Atom&lt;/p&gt;

&lt;h4 id=&quot;api-application-programming-interface-应用程序编程接口&quot;&gt;API: Application Programming Interface 应用程序编程接口&lt;/h4&gt;

&lt;p&gt;可以理解为定义的函数将会被如何使用。接口是一个媒介, 连接两端的内容。&lt;/p&gt;

&lt;p&gt;Interface的一个较好翻译是”交互”。比如User Interace, 一般的翻译为用户操作界面, 实际上是人与软件的交互过程——人输入数据, 程序输出结果。&lt;/p&gt;

&lt;p&gt;还有一种理解, API是产品经理为客户提供的产品。产品怎么做的客户并不知道, 但是客户知道有哪些产品可用以及如何使用就好。&lt;/p&gt;

&lt;h4 id=&quot;sdk-software-development-kit-软件开发工具组&quot;&gt;SDK: Software Development Kit 软件开发工具组&lt;/h4&gt;

&lt;p&gt;意如其名, 写软件的开发工具。&lt;/p&gt;

&lt;p&gt;SDK跟IDE容易混淆, 简单来说SDK更底层, 是基本平台; IDE是加了一堆插件的SDK。&lt;/p&gt;

&lt;p&gt;“A set of software development tools that allows the creation of applications for a certain software package, software framework, hardware platform, computer system, video game console, operating system, or similar development platform.”(Wikipedia)&lt;/p&gt;

&lt;h4 id=&quot;ddl-dynamic-link-library-动态链接库&quot;&gt;DDL: Dynamic Link Library 动态链接库&lt;/h4&gt;
&lt;p&gt;“在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可有多个DLL文件，一个DLL文件也可能被几个应用程序所共用。” (百度百科)&lt;/p&gt;

&lt;p&gt;相当于代码被模块化。因此一个好处是代码可以分开编译, 提高debug效率。另一个好处是在程序运行时候占用的内存变小, 因为只有需要的时候才调用某些模块。&lt;/p&gt;

&lt;h4 id=&quot;junit&quot;&gt;Junit&lt;/h4&gt;

&lt;p&gt;Unit testing framework for Java. 这个是要学的。&lt;/p&gt;</content><author><name>Jia</name></author><category term="basics" /><summary type="html">每天学一点。先写中文的。 IDE: Integrated Development Environment 集成开发环境 IDE是应用程序。代码编辑器。可以有额外的编译功能、设计UI功能。 如: Visual Studio, Android Studio, NetBeans(Oracle, Java), Eclipse, Xcode. Sorce code editor is a part of IDE. Example: Sublime text, Atom API: Application Programming Interface 应用程序编程接口 可以理解为定义的函数将会被如何使用。接口是一个媒介, 连接两端的内容。 Interface的一个较好翻译是”交互”。比如User Interace, 一般的翻译为用户操作界面, 实际上是人与软件的交互过程——人输入数据, 程序输出结果。 还有一种理解, API是产品经理为客户提供的产品。产品怎么做的客户并不知道, 但是客户知道有哪些产品可用以及如何使用就好。 SDK: Software Development Kit 软件开发工具组 意如其名, 写软件的开发工具。 SDK跟IDE容易混淆, 简单来说SDK更底层, 是基本平台; IDE是加了一堆插件的SDK。 “A set of software development tools that allows the creation of applications for a certain software package, software framework, hardware platform, computer system, video game console, operating system, or similar development platform.”(Wikipedia) DDL: Dynamic Link Library 动态链接库 “在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可有多个DLL文件，一个DLL文件也可能被几个应用程序所共用。” (百度百科) 相当于代码被模块化。因此一个好处是代码可以分开编译, 提高debug效率。另一个好处是在程序运行时候占用的内存变小, 因为只有需要的时候才调用某些模块。 Junit Unit testing framework for Java. 这个是要学的。</summary></entry><entry><title type="html">Programmer Advanced 程序员的素养</title><link href="http://localhost:4000/2018/03/19/programmer-advanced.html" rel="alternate" type="text/html" title="Programmer Advanced 程序员的素养" /><published>2018-03-19T00:00:00+08:00</published><updated>2018-03-19T00:00:00+08:00</updated><id>http://localhost:4000/2018/03/19/programmer-advanced</id><content type="html" xml:base="http://localhost:4000/2018/03/19/programmer-advanced.html">&lt;p&gt;每天学一点。先写中文的。&lt;/p&gt;

&lt;h4 id=&quot;tensorflow&quot;&gt;TensorFlow&lt;/h4&gt;

&lt;p&gt;这个最近提到的非常多, 有必要了解一下(即使我不是真的那么感兴趣)。&lt;/p&gt;

&lt;p&gt;目前的了解是, TensorFlow是一个google po出来的machine learning开源library。因为很先进而且开源所以火起来了吧(大概)。&lt;/p&gt;

&lt;p&gt;中文介绍/入门教学：
&lt;a href=&quot;http://www.tensorfly.cn/tfdoc/get_started/introduction.html&quot;&gt;http://www.tensorfly.cn/tfdoc/get_started/introduction.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我还没来得及读。&lt;/p&gt;

&lt;h4 id=&quot;apache&quot;&gt;Apache&lt;/h4&gt;

&lt;p&gt;Web server, 一款软件。只支持html, 静态网页。&lt;/p&gt;

&lt;p&gt;“Apache是以进程为基础的结构，进程要比线程消耗更多的系统开支，不太适合于多处理器环境，因此，在一个Apache Web站点扩容时，通常是增加服务器或扩充群集节点而不是增加处理器。”(百度百科)&lt;/p&gt;

&lt;h4 id=&quot;multiprocess-vs-multithread-多进程与多线程&quot;&gt;Multiprocess vs. Multithread 多进程与多线程&lt;/h4&gt;

&lt;p&gt;在知乎上看到一个非常有趣的例子, 贴在这里。&lt;/p&gt;

&lt;p&gt;1。单进程单线程：一个人在一个桌子上吃菜。2。单进程多线程：多个人在同一个桌子上一起吃菜。3。多进程单线程：多个人每个人在自己的桌子上吃菜。&lt;/p&gt;

&lt;p&gt;多线程的问题是多个人同时吃一道菜的时候容易发生争抢，例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了。。。此时就必须等一个人夹一口之后，在还给另外一个人夹菜，也就是说资源共享就会发生冲突争抢。&lt;/p&gt;

&lt;p&gt;1。对于 Windows 系统来说，【开桌子】的开销很大，因此 Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。&lt;/p&gt;

&lt;p&gt;2。对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通讯的方法。&lt;/p&gt;

&lt;p&gt;–补充：有人对这个开桌子的开销很有兴趣。我把这个问题推广说开一下。开桌子的意思是指创建进程。开销这里主要指的是时间开销。可以做个实验：创建一个进程，在进程中往内存写若干数据，然后读出该数据，然后退出。此过程重复 1000 次，相当于创建/销毁进程 1000 次。在我机器上的测试结果是：&lt;/p&gt;

&lt;p&gt;UbuntuLinux：耗时 0.8 秒&lt;/p&gt;

&lt;p&gt;Windows7：耗时 79.8 秒&lt;/p&gt;

&lt;p&gt;两者开销大约相差一百倍。&lt;/p&gt;

&lt;p&gt;这意味着，在 Windows 中，进程创建的开销不容忽视。换句话说就是，Windows 编程中不建议你创建进程，如果你的程序架构需要大量创建进程，那么最好是切换到 Linux 系统。&lt;/p&gt;

&lt;p&gt;大量创建进程的典型例子有两个，一个是 gnu autotools 工具链，用于编译很多开源代码的，他们在 Windows 下编译速度会很慢，因此软件开发人员最好是避免使用 Windows。另一个是服务器，某些服务器框架依靠大量创建进程来干活，甚至是对每个用户请求就创建一个进程，这些服务器在 Windows 下运行的效率就会很差。这”可能”也是放眼全世界范围，Linux  服务器远远多于 Windows 服务器的原因。(作者：pansz
&lt;a href=&quot;https://www.zhihu.com/question/19901763/answer/13299543&quot;&gt;https://www.zhihu.com/question/19901763/answer/13299543&lt;/a&gt;
)&lt;/p&gt;

&lt;h4 id=&quot;combinatorial-optimization-组合优化问题&quot;&gt;Combinatorial optimization 组合优化问题&lt;/h4&gt;

&lt;p&gt;A topic in applied mathematics and theoretical computer science to find the optimal object from a finite set of objects.&lt;/p&gt;

&lt;p&gt;Applications:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TSP (Traveling Salesman Problem)&lt;/li&gt;
  &lt;li&gt;MSP (Minimum Spanning Tree)&lt;/li&gt;
  &lt;li&gt;Scheduling Problem&lt;/li&gt;
  &lt;li&gt;Knapsack Problem&lt;/li&gt;
  &lt;li&gt;Bin Packing Problem&lt;/li&gt;
  &lt;li&gt;Graph Coloring Problem&lt;/li&gt;
  &lt;li&gt;Vehicle Routing Problem&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jia</name></author><category term="advanced" /><summary type="html">每天学一点。先写中文的。 TensorFlow 这个最近提到的非常多, 有必要了解一下(即使我不是真的那么感兴趣)。 目前的了解是, TensorFlow是一个google po出来的machine learning开源library。因为很先进而且开源所以火起来了吧(大概)。 中文介绍/入门教学： http://www.tensorfly.cn/tfdoc/get_started/introduction.html 我还没来得及读。 Apache Web server, 一款软件。只支持html, 静态网页。 “Apache是以进程为基础的结构，进程要比线程消耗更多的系统开支，不太适合于多处理器环境，因此，在一个Apache Web站点扩容时，通常是增加服务器或扩充群集节点而不是增加处理器。”(百度百科) Multiprocess vs. Multithread 多进程与多线程 在知乎上看到一个非常有趣的例子, 贴在这里。 1。单进程单线程：一个人在一个桌子上吃菜。2。单进程多线程：多个人在同一个桌子上一起吃菜。3。多进程单线程：多个人每个人在自己的桌子上吃菜。 多线程的问题是多个人同时吃一道菜的时候容易发生争抢，例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了。。。此时就必须等一个人夹一口之后，在还给另外一个人夹菜，也就是说资源共享就会发生冲突争抢。 1。对于 Windows 系统来说，【开桌子】的开销很大，因此 Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。 2。对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通讯的方法。 –补充：有人对这个开桌子的开销很有兴趣。我把这个问题推广说开一下。开桌子的意思是指创建进程。开销这里主要指的是时间开销。可以做个实验：创建一个进程，在进程中往内存写若干数据，然后读出该数据，然后退出。此过程重复 1000 次，相当于创建/销毁进程 1000 次。在我机器上的测试结果是： UbuntuLinux：耗时 0.8 秒 Windows7：耗时 79.8 秒 两者开销大约相差一百倍。 这意味着，在 Windows 中，进程创建的开销不容忽视。换句话说就是，Windows 编程中不建议你创建进程，如果你的程序架构需要大量创建进程，那么最好是切换到 Linux 系统。 大量创建进程的典型例子有两个，一个是 gnu autotools 工具链，用于编译很多开源代码的，他们在 Windows 下编译速度会很慢，因此软件开发人员最好是避免使用 Windows。另一个是服务器，某些服务器框架依靠大量创建进程来干活，甚至是对每个用户请求就创建一个进程，这些服务器在 Windows 下运行的效率就会很差。这”可能”也是放眼全世界范围，Linux 服务器远远多于 Windows 服务器的原因。(作者：pansz https://www.zhihu.com/question/19901763/answer/13299543 ) Combinatorial optimization 组合优化问题 A topic in applied mathematics and theoretical computer science to find the optimal object from a finite set of objects. Applications: TSP (Traveling Salesman Problem) MSP (Minimum Spanning Tree) Scheduling Problem Knapsack Problem Bin Packing Problem Graph Coloring Problem Vehicle Routing Problem</summary></entry><entry><title type="html">Second Post</title><link href="http://localhost:4000/2018/03/10/second-post.html" rel="alternate" type="text/html" title="Second Post" /><published>2018-03-10T00:00:00+08:00</published><updated>2018-03-10T00:00:00+08:00</updated><id>http://localhost:4000/2018/03/10/second-post</id><content type="html" xml:base="http://localhost:4000/2018/03/10/second-post.html">&lt;p&gt;Now there are two posts.&lt;/p&gt;</content><author><name>Jia</name></author><category term="other" /><summary type="html">Now there are two posts.</summary></entry><entry><title type="html">First Post</title><link href="http://localhost:4000/2018/03/10/first-post.html" rel="alternate" type="text/html" title="First Post" /><published>2018-03-10T00:00:00+08:00</published><updated>2018-03-10T00:00:00+08:00</updated><id>http://localhost:4000/2018/03/10/first-post</id><content type="html" xml:base="http://localhost:4000/2018/03/10/first-post.html">&lt;p&gt;This is the very first post.&lt;/p&gt;</content><author><name>Jia</name></author><category term="other" /><summary type="html">This is the very first post.</summary></entry></feed>